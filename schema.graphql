enum Risk {
  HIGH_RISK
  MIDDLE_RISK
  LOW_RISK
}

type InfectionAlert {
  howManyEncounters: Int!
  risk: Risk!
}

type Query {
  infectedEncounters(
    deviceHashesOfMyOwn: [DeviceKeyParam!]! # User own device hashes over 2 week period
    optionalOtherHashes: [String!] # If user enabled alerts from infected iOS devices, the need to send all the contact they have been in contact with
  ): [InfectionAlert]!
}

input DeviceKeyParam {
  hash: String! # hash of random generated id
  password: String! # password of this key to fetch infectedEncounters or to remove
}

input InfectedEncounterCreateInput {
  possibleInfectedHash: String!
  rssi: Int!
  hits: Int!
  time: Int!
  duration: Int!
}

input InfectedEncounterUpdateInput {
  randomPart: String
  possibleInfectedHash: String
  rssi: Int
  hits: Int
  time: Int
  duration: Int
}

input InfectedEncountersCreateInput {
  infectedEncounters: [InfectedEncounterCreateInput!]!
}

input DeviceKeyCreateInput {
  hash: String!
  password: String!
  time: Int!
}

type OkPayload {
  ok: Boolean!
}

type Mutation {
  # let Android user share their contactmoments no trace back to user will be saved!
  createInfectedEncounters(input: InfectedEncountersCreateInput!): OkPayload!

  # let iOS users register their device keys of two weeks as infected
  registerDeviceKeysAsInfected(keys: [DeviceKeyParam!]!): OkPayload!

  # user generated a device key and password so know this uuid really belongs to that user
  createDeviceKey(input: DeviceKeyCreateInput!): OkPayload!

  ## AVG -> User should be able to always remove all their data from server
  # Let user remove infected encounters on their device id's from database (AVG)
  deleteInfectedEncountersOnKeys(keys: [DeviceKeyParam!]!): OkPayload!
  removeDeviceKeysAsInfected(keys: [DeviceKeyParam!]!): OkPayload!
  removeDeviceKeys(keys: [DeviceKeyParam!]!): OkPayload!
}
